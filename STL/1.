/*

STL (Standard Template Library) in C++ is a set of ready-made classes and functions for data structures and algorithms.

ðŸ”¹ STL has 4 major components:

1.Algorithms â†’ Ready-made functions (sort, find, binary_search, etc.).
2.Containers â†’ Data structures (like vector, list, set, map).
3.Iterators â†’ A way to access elements of containers (like pointers).
4.Functors â†’ Function objects (less important at the start).



*/

#include <bits/stdc++.h>
using namespace std;


void explainPair() {
    pair<int, int> p1 = {1, 3};

    cout << p1.first << " " << p1.second<<endl;

    pair<int, pair<int, int>> p2 = {1, {3, 4}};

    cout << p2.first << " " << p2.second.second << " " << p2.second.first<<endl;

    pair<int, int> arr[] = {{1, 2}, {2, 5}, {5, 1}};

    cout << arr[1].second;
    cout<<endl;
}


void explainVector() {

    vector<int> v;
    v.push_back(1);
    v.emplace_back(2);
    /*push_back â†’ creates a temporary object, then copies/moves it into the container.
emplace_back â†’ constructs the object directly inside the container (avoids extra copy/move).*/

    vector<pair<int, int>> vec;
    vec.push_back({1, 2});// creates a temporary pair<int,int>(1,2), then moves it
    vec.emplace_back(1, 2); // directly constructs pair<int,int>(1,2) in the vector

    vector<int> v_temp1(5);//vector of size 5 with garbage values
    vector<int> v_temp2(5, 100);//vector of size 5 with value 100

    vector<int> v1 = {1,2,3,4,5};
    vector<int> v2(v1);//vector v2 is copy of vector v1
    
    
    //** Iterators' **
    vector<int>::iterator it = v.begin();//points to 1st elements memory 

    it++;//moves to next elements memory
    cout << *(it) << " ";//to print element @ that memory
    
    it = it + 2;
    cout << *(it) << " ";
    
    it = v.end();//* it will point to next memory after last element
    cout<<*(--it)<<" ";
    
    cout << v.back() << " ";
    cout<<v.front()<<endl;
    
    for(vector<int>::iterator it = v1.begin();it!=v1.end();it++){
        cout<<*(it)<<" ";
    }
    cout<<endl;
    for(auto it = v1.begin();it!=v1.end();it++){
        cout<<*(it)<<" ";
    }
     cout<<endl;
    for(auto i : v1){
        cout<<i<<" ";
    }
    cout<<endl;
    // functions' 
    
    vector<int> v3(2,100);//{100,100}
    v3.insert(v3.begin(),300);//{300,100,100}
    v3.insert(v3.begin()+1,2,10);//{300,10,10,100,100}
    
    v3.erase(v3.begin()+1);//{300,10,100,100}
    v3.erase(v3.begin()+1,v3.begin()+3);//{300,100} [start,end)
    
    for(auto i : v3){
        cout<<i<<" ";
    }
    cout<<endl;
    
    cout<<v3.size()<<endl;
    v3.pop_back();//{300,100} -> {300}
    cout<<v3.empty()<<endl;
    v3.clear();
    cout<<v3.empty()<<endl;
}


void explainList() {
    list<int> ls;

    ls.push_back(2);      // {2}
    ls.emplace_back(4);   // {2, 4}

    ls.push_front(5);     // {5, 2, 4}
    ls.emplace_front(2);  // {2, 5, 2, 4}
    
    for(auto i:ls){
        cout<<i<<" ";
    }
    cout<<endl;

    // rest functions same as vector
    // begin, end, rbegin, rend, clear, insert, size, swap
}


void explainDeque() {
    deque<int> dq;

    dq.push_back(1);     // {1}
    dq.emplace_back(2);  // {1, 2}
    dq.push_front(4);    // {4, 1, 2}
    dq.emplace_front(3); // {3, 4, 1, 2}

    dq.pop_back();       // {3, 4, 1}
    dq.pop_front();      // {4, 1}

    cout<<dq.back()<<" ";
    cout<<dq.front()<<" ";
    cout<<endl;

    // rest functions same as vector
    // begin, end, rbegin, rend, clear, insert, size, swap
}


void explainStack() {
    stack<int> st;
    st.push(1);   // {1}
    st.push(2);   // {2, 1}
    st.push(3);   // {3, 2, 1}
    st.push(3);   // {3, 3, 2, 1}
    st.emplace(5); // {5, 3, 3, 2, 1}

    cout << st.top(); // prints 5   "** st[2] is invalid **"

    st.pop(); // st looks like {3, 3, 2, 1}

    cout << st.top();  // 3
    cout << st.size(); // 4
    cout << st.empty();

    stack<int> st1, st2;
    st1.swap(st2);
    cout<<endl;
}


void explainQueue() {
    queue<int> q;
    q.push(1);     // {1}
    q.push(2);     // {1, 2}
    q.emplace(4);  // {1, 2, 4}

    q.back() += 5;

    cout << q.back();  // prints 9

    // Q is {1, 2, 9}
    cout << q.front(); // prints 1

    q.pop();           // {2, 9}

    cout << q.front(); // prints 2

    // size, swap, empty -> same as stack
    cout<<endl;
}


void explainPQ() {
    // Maximum Heap
    priority_queue<int> pq;

    pq.push(5);     // {5}
    pq.push(2);     // {5, 2}
    pq.push(8);     // {8, 5, 2}
    pq.emplace(10); // {10, 8, 5, 2}

    cout << pq.top(); // prints 10

    pq.pop();         // {8, 5, 2}

    cout << pq.top(); // prints 8

    // size, swap, empty functions same as others


    // Minimum Heap
    priority_queue<int, vector<int>, greater<int>> pq2;
    pq2.push(5);     // {5}
    pq2.push(2);     // {2, 5}
    pq2.push(8);     // {2, 5, 8}
    pq2.emplace(10); // {2, 5, 8, 10}

    cout << pq2.top(); // prints 2
}


void explainSet() {
    /*Almost all main operations on set take O(log n) time because of its underlying Red-Black Tree implementation.*/
    
    set<int> st;

    st.insert(1);     // {1}
    st.emplace(2);    // {1, 2}
    st.insert(2);     // {1, 2}
    st.insert(4);     // {1, 2, 4}
    st.insert(3);     // {1, 2, 3, 4}

    // Functionality of insert in vector
    // can be used also, that only increases efficiency

    // begin(), end(), rbegin(), rend(), size(),
    // empty() and swap() are same as those of above

    // {1, 2, 3, 4, 5}
    auto it = st.find(3);//give iterator pointing 3

    // {1, 2, 3, 4, 5}
    auto it2 = st.find(6); //give st.end()

    st.erase(5);
    st.erase(it);

    int cnt = st.count(1);//0 or 1
    cout<<cnt<<endl;
    
    for(auto i:st){
        cout<<i<<" ";
    }
    cout<<endl;
    
}

void explainMultiSet() {
    // Everything is same as set
    // only stores duplicate elements also

    multiset<int> ms;
    ms.insert(1);   // {1}
    ms.insert(1);   // {1, 1}
    ms.insert(1);   // {1, 1, 1}

    ms.erase(1);    // all 1's erased

    int cnt = ms.count(1);
    cout<<cnt<<endl;

    // only a single one erased
    ms.erase(ms.find(1));

    ms.erase(ms.find(1), next(ms.find(1), 2));
    //Iterators for associative containers like set and multiset do not support + arithmetic so use next() here
    // rest all function same as set
}




int main() {
    
    cout<<"How Pairs Works?"<<endl;
    explainPair();
    
    cout<<"\nHow Vector Works?"<<endl;
    explainVector();
    
    cout<<"\nHow List Works?"<<endl;
    explainList(); 
    
    cout<<"\nHow Deque Works?"<<endl;
    explainDeque();
    
    cout<<"\nHow Stack Works?"<<endl;
    explainStack();
    
    cout<<"\nHow Queue Works?"<<endl;
    explainQueue();
    
    cout<<"\nHow Priority Queue Works?"<<endl;
    explainPQ();
    
    cout<<"\nHow Set Works?"<<endl;
    explainSet(); 
    
    cout<<"\nHow Multiset Works?"<<endl;
    explainMultiSet();
    
    
    /*
    1.Almost all main operations on set take O(log n) time because of its underlying Red-Black Tree implementation.
    2.Almost all main operations on stack and queue take O(1) time
    3.Priority Queue>
    Only accessing i.e top, size, empty are O(1).
    But insertion (push) and deletion (pop) are O(log n).
    */
    

    return 0;
}
